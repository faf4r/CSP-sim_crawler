


**时间限制：** 5.0 秒 


**空间限制：** 512 MiB

[下载题目目录（样例文件）](examples/CSP201909-3.zip)




## 题目背景

君君是个喜欢旅行的女孩子，世界那么大，她哪里都想去看看。这个暑假，她踏遍了大江南北，感慨于祖国幅员的辽阔。
开学了，君君打算整理一下最近拍的照片，却发现自己电脑上 Linux 的图形界面似乎罢工了。面对着终端里不断闪动的光标，她灵机一动……

## 题目描述

本题中，你需要将图片转换为终端中可以显示的字符画。

你将得到一张 24 位图片，这意味着其中的像素表示为 RGB 三原色的形式，而每种颜色的取值范围为 0 到 255（一个字节），因此每个像素占用的空间为 24 比特。
你需要这张图片分割为指定数量的块。对于每一块，你需要计算所有像素的三个颜色分量的**平均值**，并输出对应颜色的字符形成字符画。

为了在终端中输出彩色的字符，你需要使用特殊的`转义序列`。在目前通行的终端规范中，与颜色相关的转义序列包括：

* `ESC [ 38; 2; R; G; B m` 更改终端的**前景色（字符的颜色）**为 $(R, G, B)$
* `ESC [ 48; 2; R; G; B m` 更改终端的**背景色（未被字符遮盖处的颜色）**为 $(R, G, B)$
* `ESC [ 0 m` 重置终端的颜色状态为默认值（前景色为白色 $(255, 255, 255)$，背景色为黑色 $(0, 0, 0)$）

你只需要在输出中加入这些转义序列，就能够控制终端中显示的字符颜色。在书写转义序列时，有以下注意事项：

* 所有空格都是为了方便辨认而添加的，**不需要出现**在实际的转义序列输出中
* `ESC` **不是字面上的三个字符**，而是 ASCII 序号为 27 （八进制表示为 033） 的**一个字符**，代表转义序列的开始。在 C/C++/Java/Python 中，你都可以使用 `\033` 或 `\x1b` 来在字符串中使用这个字符。
* 每个颜色分量的值需要在 0 到 255 的范围内
* 对终端状态的更改在当前转义序列结束（即最后的 `m` 字符）后立刻生效，直到下一个序列再次改变状态为止

为了更方便理解，我们给出一个例子（为了显示效果而分行，实际输出时**为一行**）：

```
\033[38;2;255;0;0mHello\033[0m \033[38;2;0;0;255m
\033[48;2;255;255;255mWorld\033[0m\n
```

当这个字符串被输出到终端中，你将会看到类似下面的效果：

 <img src="attachments/CSP201909-3-0.png" alt="img" align="middle"/> 

特别需要注意的是，在程序完成输出后，应该主动恢复终端的颜色状态，否则可能让之后运行的程序表现异常。

## 输入格式

从标准输入读入数据。

输入的第一行为两个整数 $m, n$，分别表示图片的宽和高。第二行为两个整数 $p, q$，分别表示每一小块的宽和高。保证 $p$ 整除 $m$，并且 $q$ 整除 $n$，也就是说图片总是能被分割成整数块。

接下来共有 $m \times n$ 行，每一行是图片中的一个像素，按照从左到右、从上到下的顺序列出。每个像素的颜色以 HTML 颜色代码的形式表示，格式为 `#abcdef`，表示该像素的 R、G、B 三个分量分别是 `(0xab, 0xcd, 0xef)`（注意为**16进制**）。此外，为了使得表达简洁，`#aabbcc` 可以被缩写为 `#abc`，`#aaaaaa` 可以被缩写为 `#a`，你需要处理这些情况。

## 输出格式

输出到标准输出。

输出包含两部分，每一个输出中应该有**恰好** $(mn)/(pq)$ 个空格（`' '`）以及 $n/q$ 个换行符（`'\n'`），和若干个转义序列。空格用于绘制色块（呈现出的即为其**背景色**），转义序列用于改变颜色。每一个色块都由 $p \times q$ 个像素组成，其三个颜色分量值分别是对应区域中所有像素该分量值的平均值（除法**向零取整**即可）。

由于正确的答案显然不止一种，为了方便判定，我们有以下的约定：

* 初始时终端的前景色和背景色都为默认值（前景白色，背景黑色）
* 减少控制序列的冗余，这包含以下的情况：
  * 如果下一个字符的颜色刚好与默认值完全相同，你应当直接使用重置转义序列，而非手动更改颜色
  * 如果某个字符的前景色/背景色与其前一个字符相同，或者对颜色的更改并不影响最终显示效果，则不应该出现更改这个属性的控制序列
* 在输出每一行字符后，如果终端颜色不是默认值，你应该重置终端的颜色状态

为了便于观察和评测，你需要**将输出中的所有字符转换为 ASCII 编码转义后的格式再进行输出**。即，如果某个字符的 16 进制编码是 `0xAB`，则你应该在输出文件中写入 `\xAB`，**注意大小写**。**所有的**字符都需要被转义（包括空格、换行等空白字符）；所有字符的转义序列顺序输出，不需要任何形式的分隔符号；在输出所有的转义序列后，不需要写入换行符。也就是说，最终的输出文件**只有一行**，并且其中所有内容都是原本输出字符的 ASCII 转义序列。

如果你使用的是 Linux 系统，你可以在终端中运行如下的命令查看输出文件的真实显示效果（其中 `1.out` 是文件名）：

```
echo -ne $(cat 1.out)
```




## 样例1输入

```plain
1 1
1 1
#010203

```



## 样例 1 输出

```text
\x1B\x5B\x34\x38\x3B\x32\x3B\x31\x3B\x32\x3B
\x33\x6D\x20\x1B\x5B\x30\x6D\x0A
```

注意上面的换行是由于排版限制而添加的，实际输出中**无需也不能换行**。

## 样例1解释

输入文件图片大小为 $1 \times 1$，要求的色块大小为 $1 \times 1$，因此原样输出即可。在输出后需要重置背景色。




## 样例2输入

```plain
2 2
1 2
#111111
#0
#000000
#111

```



## 样例 2 输出

```text
\x1B\x5B\x34\x38\x3B\x32\x3B\x38\x3B\x38\x3B
\x38\x6D\x20\x20\x1B\x5B\x30\x6D\x0A
```

此处的换行同样是由于排版限制添加的。

## 样例2解释


输入文件图片大小为 $2 \times 2$，要求的色块大小为 $1 \times 2$，因此将被切为两个色块。

第一个色块的颜色是左侧两个像素的平均值，三个颜色分量为 $(8, 8, 8)$；第二个色块同理，计算得到的颜色分量相同。因此最终只需要更改一次终端的背景色，并输出两个空格用于显示即可。

## 子任务

 
	


<table class="table table-bordered"><thead><tr><th rowspan="1">测试点</th><th rowspan="1">$m$</th><th rowspan="1">$n$</th><th rowspan="1">$p=1,\,q=2$</th></tr></thead><tbody><tr><td rowspan="1">1, 2</td><td rowspan="1">$\leq 10$</td><td rowspan="1">$\leq 10$</td><td rowspan="1">是</td></tr><tr><td rowspan="1">3, 4</td><td rowspan="1">$\leq 10^{2}$</td><td rowspan="1">$\leq 10^{2}$</td><td rowspan="4">否</td></tr><tr><td rowspan="1">5, 6</td><td rowspan="1">$\leq 640$</td><td rowspan="1">$\leq 640$</td></tr><tr><td rowspan="1">7, 8</td><td rowspan="1">$\leq 800$</td><td rowspan="1">$\leq 800$</td></tr><tr><td rowspan="1">9, 10</td><td rowspan="1">$\leq 1,920$</td><td rowspan="1">$\leq 1,080$</td></tr></tbody></table> 